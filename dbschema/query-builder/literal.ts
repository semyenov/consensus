// GENERATED by @edgedb/generate v0.5.4

// import {
//   Cardinality,
//   ExpressionKind,
//   BaseType,
//   BaseTypeToTsType,
//   makeType,
//   ScalarType
// } from "edgedb/dist/reflection/index";

// import type {$expr_Literal} from "./literal";
import { Cardinality, ExpressionKind } from 'edgedb/dist/reflection/index'

import { spec } from './__spec__'
import { makeType } from './hydrate'
import { $expressionify } from './path'

import type {
  BaseType,
  BaseTypeToTsType,
  Expression,
  ScalarType,
} from './typesystem'

export type $expr_Literal<Type extends BaseType = BaseType> = Expression<{
  __element__: Type
  __cardinality__: Cardinality.One
  __kind__: ExpressionKind.Literal
  __value__: any
}>

export function literal<
  T extends BaseType,
  TsType extends BaseTypeToTsType<T> = BaseTypeToTsType<T>,
  ExprType extends $expr_Literal<T> = $expr_Literal<T>,
>(type: T, value: TsType): ExprType {
  return $expressionify({
    __element__: type,
    __cardinality__: Cardinality.One,
    __kind__: ExpressionKind.Literal,
    __value__: value,
  }) as ExprType
}

export const $nameMapping = new Map<string, string>([
  ...([...spec.values()].map((type) => {
    return [type.name, type.id]
  }) as any),
  ['std::number', '00000000-0000-0000-0000-0000000001ff'],
])

export function $getType(id: string): (val: any) => $expr_Literal<ScalarType> {
  return makeType(spec, id, literal) as any
}

export function $getTypeByName(
  name: string,
): (val: any) => $expr_Literal<ScalarType> {
  return makeType(spec, $nameMapping.get(name)!, literal) as any
}
