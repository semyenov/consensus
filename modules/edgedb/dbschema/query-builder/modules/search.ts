// GENERATED by @edgedb/generate v0.5.4

import * as $ from "../reflection";
import * as _ from "../imports";
import type * as _extpgvector from "./ext/pgvector";
import type * as _std from "./std";
export type $EmbeddingVector = $.ScalarType<"ext::pgvector::vector", Float32Array, Float32Array | number[]>;
const EmbeddingVector: $.scalarTypeWithConstructor<_extpgvector.$vector, number[]> = $.makeType<$.scalarTypeWithConstructor<_extpgvector.$vector, number[]>>(_.spec, "02fa72ef-66b3-11ef-ba4f-11e88444451b", _.syntax.literal);

export type $VectorSearchableλShape = $.typeutil.flatten<_std.$Object_8ce8c71ee4fa5f73840c22d7eaa58588λShape & {
  "embedding": $.PropertyDesc<$EmbeddingVector, $.Cardinality.One, false, false, false, false>;
}>;
type $VectorSearchable = $.ObjectType<"search::VectorSearchable", $VectorSearchableλShape, null, [
  ..._std.$Object_8ce8c71ee4fa5f73840c22d7eaa58588['__exclusives__'],
]>;
const $VectorSearchable = $.makeType<$VectorSearchable>(_.spec, "02fa7fb8-66b3-11ef-ad7b-27ab07d022d7", _.syntax.literal);

const VectorSearchable: $.$expr_PathNode<$.TypeSet<$VectorSearchable, $.Cardinality.Many>, null> = _.syntax.$PathNode($.$toSet($VectorSearchable, $.Cardinality.Many), null);

type vector_searchλFuncExpr<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$EmbeddingVector>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$number>>,
> = $.$expr_Function<
  $.NamedTupleType<{item: $VectorSearchable, similarity: _std.$float64}>, $.Cardinality.Many
>;
function vector_search<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<$EmbeddingVector>>,
  P2 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$number>>,
>(
  search_vector: P1,
  search_limit: P2,
): vector_searchλFuncExpr<P1, P2>;
function vector_search(...args: any[]) {
  const {returnType, cardinality, args: positionalArgs, namedArgs} = _.syntax.$resolveOverload('search::vector_search', args, _.spec, [
    {args: [{typeId: "02fa72ef-66b3-11ef-ba4f-11e88444451b", optional: false, setoftype: false, variadic: false}, {typeId: "00000000-0000-0000-0000-0000000001ff", optional: false, setoftype: false, variadic: false}], returnTypeId: "02fc0cb0-66b3-11ef-b1fb-d7e91a31e9f3", returnTypemod: "SetOfType"},
  ]);
  return _.syntax.$expressionify({
    __kind__: $.ExpressionKind.Function,
    __element__: returnType,
    __cardinality__: cardinality,
    __name__: "search::vector_search",
    __args__: positionalArgs,
    __namedargs__: namedArgs,
  }) as any;
};



export { EmbeddingVector, $VectorSearchable, VectorSearchable };

type __defaultExports = {
  "EmbeddingVector": typeof EmbeddingVector;
  "VectorSearchable": typeof VectorSearchable;
  "vector_search": typeof vector_search
};
const __defaultExports: __defaultExports = {
  "EmbeddingVector": EmbeddingVector,
  "VectorSearchable": VectorSearchable,
  "vector_search": vector_search
};
export default __defaultExports;
